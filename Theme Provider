import React, { createContext, useContext, useState, useEffect } from 'react';
import { User } from '@/entities/User';

const ThemeContext = createContext();

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

export const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('dark'); // Always dark mode
  const [weatherCondition, setWeatherCondition] = useState('clear');
  const [temperatureUnit, setTemperatureUnit] = useState('celsius');
  const [user, setUser] = useState(null);

  useEffect(() => {
    const loadUserData = async () => {
      try {
        const currentUser = await User.me();
        setUser(currentUser);
        if (currentUser?.preferences?.temperature_unit) {
          setTemperatureUnit(currentUser.preferences.temperature_unit);
        }
      } catch (error) {
        // User is not logged in, defaults will be used.
        console.log("User not logged in, using default preferences.");
      }
    };
    loadUserData();
  }, []);

  // Remove theme switching functionality - theme is always dark
  const toggleTheme = () => {
    // Do nothing - theme stays dark
  };

  const toggleTemperatureUnit = async () => {
    const newUnit = temperatureUnit === 'celsius' ? 'fahrenheit' : 'celsius';
    setTemperatureUnit(newUnit); // Optimistic update for UI responsiveness

    if (user) { // Only update if user is logged in
      try {
        // Create a deep copy of preferences to avoid mutation issues
        const currentPrefs = JSON.parse(JSON.stringify(user.preferences || {}));
        currentPrefs.temperature_unit = newUnit;

        await User.updateMyUserData({
          preferences: currentPrefs,
        });
      } catch (error) {
        console.error("Failed to save temperature unit preference:", error);
        // Optional: revert state if API call fails
        setTemperatureUnit(temperatureUnit);
      }
    }
  };

  const updateWeatherCondition = (condition) => {
    setWeatherCondition(condition?.toLowerCase() || 'clear');
  };

  const getTimeOfDay = () => {
    const hour = new Date().getHours();
    if (hour >= 5 && hour < 12) return 'morning';
    if (hour >= 12 && hour < 17) return 'afternoon';
    if (hour >= 17 && hour < 21) return 'evening';
    return 'night';
  };

  const getAnimatedBackground = () => {
    const timeOfDay = getTimeOfDay();
    
    // Always use dark theme backgrounds
    const backgrounds = {
      morning: 'bg-gradient-to-br from-gray-800 via-gray-700 to-gray-900',
      afternoon: 'bg-gradient-to-br from-gray-900 via-blue-900 to-indigo-900',
      evening: 'bg-gradient-to-br from-purple-900 via-gray-800 to-indigo-900',
      night: 'bg-gradient-to-br from-gray-900 via-black to-blue-900'
    };

    // Weather condition overlays for dark theme
    const weatherOverlays = {
      rainy: 'from-blue-900/30 to-gray-800/30',
      cloudy: 'from-gray-700/40 to-gray-600/40',
      snowy: 'from-blue-100/20 to-white/10',
      thunderstorm: 'from-purple-900/50 to-gray-900/50',
      sunny: 'from-yellow-600/20 to-orange-600/20',
      clear: ''
    };

    const baseGradient = backgrounds[timeOfDay];
    const weatherOverlay = weatherOverlays[weatherCondition] || '';

    return { baseGradient, weatherOverlay };
  };

  const value = {
    theme, // Always 'dark'
    toggleTheme, // Does nothing now
    weatherCondition,
    updateWeatherCondition,
    getAnimatedBackground,
    getTimeOfDay,
    temperatureUnit,
    toggleTemperatureUnit,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};
